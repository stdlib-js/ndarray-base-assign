{"version":3,"file":"index.mjs","sources":["../lib/nd_accessors.js","../lib/nd.js","../lib/main.js","../lib/0d.js","../lib/1d.js","../lib/2d.js","../lib/3d.js","../lib/4d.js","../lib/5d.js","../lib/6d.js","../lib/7d.js","../lib/8d.js","../lib/9d.js","../lib/10d.js","../lib/0d_accessors.js","../lib/1d_accessors.js","../lib/2d_accessors.js","../lib/3d_accessors.js","../lib/4d_accessors.js","../lib/5d_accessors.js","../lib/6d_accessors.js","../lib/7d_accessors.js","../lib/8d_accessors.js","../lib/9d_accessors.js","../lib/10d_accessors.js","../lib/2d_blocked.js","../lib/3d_blocked.js","../lib/4d_blocked.js","../lib/5d_blocked.js","../lib/6d_blocked.js","../lib/7d_blocked.js","../lib/8d_blocked.js","../lib/9d_blocked.js","../lib/10d_blocked.js","../lib/2d_blocked_accessors.js","../lib/3d_blocked_accessors.js","../lib/4d_blocked_accessors.js","../lib/5d_blocked_accessors.js","../lib/6d_blocked_accessors.js","../lib/7d_blocked_accessors.js","../lib/8d_blocked_accessors.js","../lib/9d_blocked_accessors.js","../lib/10d_blocked_accessors.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Assigns elements in an n-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assignnd( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assignnd( x, y ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar ordx;\n\tvar ordy;\n\tvar len;\n\tvar get;\n\tvar set;\n\tvar sh;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i;\n\n\tsh = x.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Cache references to the input and output ndarray data buffers:\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache references to the respective stride arrays:\n\tsx = x.strides;\n\tsy = y.strides;\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays:\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache the respective array orders:\n\tordx = x.order;\n\tordy = y.order;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over each element based on the linear **view** index, regardless as to how the data is stored in memory...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tix = vind2bind( sh, sx, ox, ordx, i, MODE );\n\t\tiy = vind2bind( sh, sy, oy, ordy, i, MODE );\n\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assignnd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Assigns elements in an n-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Float64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assignnd( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0 ]\n*/\nfunction assignnd( x, y ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar ordx;\n\tvar ordy;\n\tvar len;\n\tvar sh;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i;\n\n\tsh = x.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Cache references to the input and output ndarray data buffers:\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache references to the respective stride arrays:\n\tsx = x.strides;\n\tsy = y.strides;\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays:\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache the respective array orders:\n\tordx = x.order;\n\tordy = y.order;\n\n\t// Iterate over each element based on the linear **view** index, regardless as to how the data is stored in memory...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tix = vind2bind( sh, sx, ox, ordx, i, MODE );\n\t\tiy = vind2bind( sh, sy, oy, ordy, i, MODE );\n\t\tybuf[ iy ] = xbuf[ ix ];\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assignnd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n// MODULES //\n\nimport isComplexDataType from '@stdlib/ndarray-base-assert-is-complex-floating-point-data-type';\n\nimport isRealDataType from '@stdlib/ndarray-base-assert-is-real-data-type';\nimport isComplexArray from '@stdlib/array-base-assert-is-complex-typed-array';\nimport isBooleanArray from '@stdlib/array-base-assert-is-booleanarray';\nimport iterationOrder from '@stdlib/ndarray-base-iteration-order';\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport castReturn from '@stdlib/complex-base-cast-return';\nimport complexCtors from '@stdlib/complex-ctors';\nimport minmaxViewBufferIndex from '@stdlib/ndarray-base-minmax-view-buffer-index';\nimport ndarray2object from '@stdlib/ndarray-base-ndarraylike2object';\nimport reinterpretComplex from '@stdlib/strided-base-reinterpret-complex';\nimport reinterpretBoolean from '@stdlib/strided-base-reinterpret-boolean';\nimport gscal from '@stdlib/blas-base-gscal';\nimport blockedaccessorassign2d from './2d_blocked_accessors.js';\nimport blockedaccessorassign3d from './3d_blocked_accessors.js';\nimport blockedaccessorassign4d from './4d_blocked_accessors.js';\nimport blockedaccessorassign5d from './5d_blocked_accessors.js';\nimport blockedaccessorassign6d from './6d_blocked_accessors.js';\nimport blockedaccessorassign7d from './7d_blocked_accessors.js';\nimport blockedaccessorassign8d from './8d_blocked_accessors.js';\nimport blockedaccessorassign9d from './9d_blocked_accessors.js';\nimport blockedaccessorassign10d from './10d_blocked_accessors.js';\nimport blockedassign2d from './2d_blocked.js';\nimport blockedassign3d from './3d_blocked.js';\nimport blockedassign4d from './4d_blocked.js';\nimport blockedassign5d from './5d_blocked.js';\nimport blockedassign6d from './6d_blocked.js';\nimport blockedassign7d from './7d_blocked.js';\nimport blockedassign8d from './8d_blocked.js';\nimport blockedassign9d from './9d_blocked.js';\nimport blockedassign10d from './10d_blocked.js';\nimport accessorassign0d from './0d_accessors.js';\nimport accessorassign1d from './1d_accessors.js';\nimport accessorassign2d from './2d_accessors.js';\nimport accessorassign3d from './3d_accessors.js';\nimport accessorassign4d from './4d_accessors.js';\nimport accessorassign5d from './5d_accessors.js';\nimport accessorassign6d from './6d_accessors.js';\nimport accessorassign7d from './7d_accessors.js';\nimport accessorassign8d from './8d_accessors.js';\nimport accessorassign9d from './9d_accessors.js';\nimport accessorassign10d from './10d_accessors.js';\nimport accessorassignnd from './nd_accessors.js';\nimport assign0d from './0d.js';\nimport assign1d from './1d.js';\nimport assign2d from './2d.js';\nimport assign3d from './3d.js';\nimport assign4d from './4d.js';\nimport assign5d from './5d.js';\nimport assign6d from './6d.js';\nimport assign7d from './7d.js';\nimport assign8d from './8d.js';\nimport assign9d from './9d.js';\nimport assign10d from './10d.js';\nimport assignnd from './nd.js';\n\n// VARIABLES //\n\nvar ASSIGN = [\n\tassign0d,\n\tassign1d,\n\tassign2d,\n\tassign3d,\n\tassign4d,\n\tassign5d,\n\tassign6d,\n\tassign7d,\n\tassign8d,\n\tassign9d,\n\tassign10d\n];\n\nvar ACCESSOR_ASSIGN = [\n\taccessorassign0d,\n\taccessorassign1d,\n\taccessorassign2d,\n\taccessorassign3d,\n\taccessorassign4d,\n\taccessorassign5d,\n\taccessorassign6d,\n\taccessorassign7d,\n\taccessorassign8d,\n\taccessorassign9d,\n\taccessorassign10d\n];\n\nvar BLOCKED_ASSIGN = [\n\tblockedassign2d, // 0\n\tblockedassign3d,\n\tblockedassign4d,\n\tblockedassign5d,\n\tblockedassign6d,\n\tblockedassign7d,\n\tblockedassign8d,\n\tblockedassign9d,\n\tblockedassign10d // 8\n];\n\nvar BLOCKED_ACCESSOR_ASSIGN = [\n\tblockedaccessorassign2d, // 0\n\tblockedaccessorassign3d,\n\tblockedaccessorassign4d,\n\tblockedaccessorassign5d,\n\tblockedaccessorassign6d,\n\tblockedaccessorassign7d,\n\tblockedaccessorassign8d,\n\tblockedaccessorassign9d,\n\tblockedaccessorassign10d // 8\n];\n\nvar MAX_DIMS = ASSIGN.length - 1;\n\n// TODO: consider adding a package utility for mapping a complex dtype to its complementary real-valued counterpart\nvar COMPLEX_TO_REAL = { // WARNING: this table needs to be manually updated if we add support for additional complex number dtypes\n\t'complex128': 'float64',\n\t'complex64': 'float32',\n\t'complex32': 'float16'\n};\n\n// FUNCTIONS //\n\n/**\n* Converts a boolean ndarray to an 8-bit unsigned integer ndarray.\n*\n* ## Notes\n*\n* -   The function mutates the input ndarray object.\n*\n* @private\n* @param {Object} x - input ndarray object\n* @returns {Object} output ndarray object\n*/\nfunction boolean2uint8( x ) {\n\tx.data = reinterpretBoolean( x.data, 0 );\n\tx.accessorProtocol = false;\n\treturn x;\n}\n\n/**\n* Converts a complex-valued floating-point ndarray to a real-valued floating-point ndarray.\n*\n* ## Notes\n*\n* -   The function mutates the input ndarray object.\n*\n* @private\n* @param {Object} x - input ndarray object\n* @returns {Object} output ndarray object\n*/\nfunction complex2real( x ) {\n\tvar ndims = x.shape.length;\n\n\tx.data = reinterpretComplex( x.data, 0 );\n\tx.accessorProtocol = false;\n\tx.dtype = COMPLEX_TO_REAL[ String( x.dtype ) ];\n\tx.strides = gscal( ndims, 2, x.strides, 1 );\n\tx.offset *= 2;\n\n\t// Append a trailing dimension where each element is the real and imaginary component for a corresponding element in the original input ndarray (note: this means that a two-dimensional complex-valued ndarray becomes a three-dimensional real-valued ndarray; while this does entail additional loop overhead, it is still significantly faster than sending complex-valued ndarrays down the accessor path):\n\tx.shape.push( 2 ); // real and imaginary components\n\n\t// Augment the strides, where we assume that real and imaginary components are adjacent in memory...\n\tif ( ndims === 0 ) {\n\t\tx.strides[ 0 ] = 1;\n\t} else {\n\t\tx.strides.push( 1 );\n\t}\n\treturn x;\n}\n\n// MAIN //\n\n/**\n* Assigns elements in an input ndarray to elements in an output ndarray.\n*\n* ## Notes\n*\n* -   Each provided ndarray should be an object with the following properties:\n*\n*     -   **dtype**: data type.\n*     -   **data**: data buffer.\n*     -   **shape**: dimensions.\n*     -   **strides**: stride lengths.\n*     -   **offset**: index offset.\n*     -   **order**: specifies whether an ndarray is row-major (C-style) or column major (Fortran-style).\n*\n* @param {ArrayLikeObject<Object>} arrays - array-like object containing one input array and one output array\n* @throws {Error} arrays must have the same number of dimensions\n* @throws {Error} arrays must have the same shape\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n* var sy = [ 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign( [ x, y ] );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction assign( arrays ) {\n\tvar ndims;\n\tvar xmmv;\n\tvar ymmv;\n\tvar shx;\n\tvar shy;\n\tvar iox;\n\tvar ioy;\n\tvar len;\n\tvar ord;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ns;\n\tvar x;\n\tvar y;\n\tvar d;\n\tvar i;\n\n\t// Unpack the ndarrays and standardize ndarray meta data:\n\tx = ndarray2object( arrays[ 0 ] );\n\ty = ndarray2object( arrays[ 1 ] );\n\n\t// Check for known array types which can be reinterpreted for better iteration performance...\n\tif ( isBooleanArray( x.data ) && isBooleanArray( y.data ) ) {\n\t\tx = boolean2uint8( x );\n\t\ty = boolean2uint8( y );\n\t} else if ( isComplexArray( x.data ) && isComplexArray( y.data ) ) {\n\t\tx = complex2real( x );\n\t\ty = complex2real( y );\n\t}\n\t// Determine whether we are casting a real data type to a complex data type and we need to use a specialized accessor (note: we don't support the other way, complex-to-real, as this is not an allowed (mostly) safe cast; note: we cannot create a specialized view for assigning only real components, as the imaginary component for each element in `y` also needs to be set to zero and while we could perform two passes, it's not clear it's worth the effort)...\n\telse if ( isRealDataType( x.dtype ) && isComplexDataType( y.dtype ) ) {\n\t\tx.accessorProtocol = true;\n\t\tx.accessors[ 0 ] = castReturn( x.accessors[ 0 ], 2, complexCtors( String( y.dtype ) ) ); // eslint-disable-line max-len\n\t}\n\t// Verify that the input and output arrays have the same number of dimensions...\n\tshx = x.shape;\n\tshy = y.shape;\n\tndims = shx.length;\n\tif ( ndims !== shy.length ) {\n\t\tthrow new Error( 'invalid arguments. Arrays must have the same number of dimensions (i.e., same rank). ndims(x) == '+ndims+'. ndims(y) == '+shy.length+'.' );\n\t}\n\t// Determine whether we can avoid iteration altogether...\n\tif ( ndims === 0 ) {\n\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\treturn ACCESSOR_ASSIGN[ ndims ]( x, y );\n\t\t}\n\t\treturn ASSIGN[ ndims ]( x, y );\n\t}\n\t// Verify that the input and output arrays have the same dimensions...\n\tlen = 1; // number of elements\n\tns = 0;  // number of singleton dimensions\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\td = shx[ i ];\n\t\tif ( d !== shy[ i ] ) {\n\t\t\tthrow new Error( format('1kH0d') );\n\t\t}\n\t\t// Note that, if one of the dimensions is `0`, the length will be `0`...\n\t\tlen *= d;\n\n\t\t// Check whether the current dimension is a singleton dimension...\n\t\tif ( d === 1 ) {\n\t\t\tns += 1;\n\t\t}\n\t}\n\t// Check whether we were provided empty ndarrays...\n\tif ( len === 0 ) {\n\t\treturn;\n\t}\n\t// Determine whether the ndarrays are one-dimensional and thus readily translate to one-dimensional strided arrays...\n\tif ( ndims === 1 ) {\n\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\treturn ACCESSOR_ASSIGN[ ndims ]( x, y );\n\t\t}\n\t\treturn ASSIGN[ ndims ]( x, y );\n\t}\n\tsx = x.strides;\n\tsy = y.strides;\n\n\t// Determine whether the ndarray has only **one** non-singleton dimension (e.g., ndims=4, shape=[10,1,1,1]) so that we can treat the ndarrays as being equivalent to one-dimensional strided arrays...\n\tif ( ns === ndims-1 ) {\n\t\t// Get the index of the non-singleton dimension...\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tif ( shx[ i ] !== 1 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx.shape = [ shx[i] ];\n\t\ty.shape = x.shape;\n\t\tx.strides = [ sx[i] ];\n\t\ty.strides = [ sy[i] ];\n\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\treturn ACCESSOR_ASSIGN[ 1 ]( x, y );\n\t\t}\n\t\treturn ASSIGN[ 1 ]( x, y );\n\t}\n\tiox = iterationOrder( sx ); // +/-1\n\tioy = iterationOrder( sy ); // +/-1\n\n\t// Determine whether we can avoid blocked iteration...\n\tord = strides2order( sx );\n\tif ( iox !== 0 && ioy !== 0 && ord === strides2order( sy ) ) {\n\t\t// Determine the minimum and maximum linear indices which are accessible by the array views:\n\t\txmmv = minmaxViewBufferIndex( shx, sx, x.offset );\n\t\tymmv = minmaxViewBufferIndex( shy, sy, y.offset );\n\n\t\t// Determine whether we can ignore shape (and strides) and treat the ndarrays as linear one-dimensional strided arrays...\n\t\tif ( len === ( xmmv[1]-xmmv[0]+1 ) && len === ( ymmv[1]-ymmv[0]+1 ) ) {\n\t\t\t// Note: the above is equivalent to @stdlib/ndarray/base/assert/is-contiguous, but in-lined so we can retain computed values...\n\t\t\tif ( iox === 1 ) {\n\t\t\t\tox = xmmv[ 0 ];\n\t\t\t} else {\n\t\t\t\tox = xmmv[ 1 ];\n\t\t\t}\n\t\t\tif ( ioy === 1 ) {\n\t\t\t\toy = ymmv[ 0 ];\n\t\t\t} else {\n\t\t\t\toy = ymmv[ 1 ];\n\t\t\t}\n\t\t\tx.shape = [ len ];\n\t\t\ty.shape = x.shape;\n\t\t\tx.strides = [ iox ];\n\t\t\ty.strides = [ ioy ];\n\t\t\tx.offset = ox;\n\t\t\ty.offset = oy;\n\t\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\t\treturn ACCESSOR_ASSIGN[ 1 ]( x, y );\n\t\t\t}\n\t\t\treturn ASSIGN[ 1 ]( x, y );\n\t\t}\n\t\t// At least one ndarray is non-contiguous, so we cannot directly use one-dimensional array functionality...\n\n\t\t// Determine whether we can use simple nested loops...\n\t\tif ( ndims <= MAX_DIMS ) {\n\t\t\t// So long as iteration for each respective array always moves in the same direction (i.e., no mixed sign strides), we can leverage cache-optimal (i.e., normal) nested loops without resorting to blocked iteration...\n\t\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\t\treturn ACCESSOR_ASSIGN[ ndims ]( x, y, ord === 1 );\n\t\t\t}\n\t\t\treturn ASSIGN[ ndims ]( x, y, ord === 1 );\n\t\t}\n\t\t// Fall-through to blocked iteration...\n\t}\n\t// At this point, we're either dealing with non-contiguous n-dimensional arrays, high dimensional n-dimensional arrays, and/or arrays having differing memory layouts, so our only hope is that we can still perform blocked iteration...\n\n\t// Determine whether we can perform blocked iteration...\n\tif ( ndims <= MAX_DIMS ) {\n\t\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\t\treturn BLOCKED_ACCESSOR_ASSIGN[ ndims-2 ]( x, y );\n\t\t}\n\t\treturn BLOCKED_ASSIGN[ ndims-2 ]( x, y );\n\t}\n\t// Fall-through to linear view iteration without regard for how data is stored in memory (i.e., take the slow path)...\n\tif ( x.accessorProtocol || y.accessorProtocol ) {\n\t\treturn accessorassignnd( x, y );\n\t}\n\tassignnd( x, y );\n}\n\n// EXPORTS //\n\nexport default assign;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a zero-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0 ] );\n* var ybuf = new Float64Array( 1 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [];\n*\n* // Define the array strides:\n* var sx = [ 0 ];\n* var sy = [ 0 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign0d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0 ]\n*/\nfunction assign0d( x, y ) {\n\ty.data[ y.offset ] = x.data[ x.offset ];\n}\n\n\n// EXPORTS //\n\nexport default assign0d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a one-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Float64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 4 ];\n*\n* // Define the array strides:\n* var sx = [ 2 ];\n* var sy = [ 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign1d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 4.0, 6.0, 8.0 ]\n*/\nfunction assign1d( x, y ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dy0;\n\tvar S0;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables: dimensions and loop offset (pointer) increments...\n\tS0 = x.shape[ 0 ];\n\tdx0 = x.strides[ 0 ];\n\tdy0 = y.strides[ 0 ];\n\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tybuf[ iy ] = xbuf[ ix ];\n\t\tix += dx0;\n\t\tiy += dy0;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a two-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Float64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign2d( x, y, true );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0 ]\n*/\nfunction assign2d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dy0;\n\tvar dy1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdx0 = sx[ 1 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 0 ] - ( S0*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 1 ];\n\t\tdy1 = sy[ 0 ] - ( S0*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\tix += dx0;\n\t\t\tiy += dy0;\n\t\t}\n\t\tix += dx1;\n\t\tiy += dy1;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a three-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n* var sy = [ 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign3d( x, y, true );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction assign3d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdx0 = sx[ 2 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx2 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 2 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[2] );\n\t\tdy2 = sy[ 0 ] - ( S1*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\tix += dx0;\n\t\t\t\tiy += dy0;\n\t\t\t}\n\t\t\tix += dx1;\n\t\t\tiy += dy1;\n\t\t}\n\t\tix += dx2;\n\t\tiy += dy2;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a four-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n* var sy = [ 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign4d( x, y, true );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction assign4d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdx0 = sx[ 3 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 2 ] - ( S0*sx[3] );\n\t\tdx2 = sx[ 1 ] - ( S1*sx[2] );\n\t\tdx3 = sx[ 0 ] - ( S2*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 3 ];\n\t\tdy1 = sy[ 2 ] - ( S0*sy[3] );\n\t\tdy2 = sy[ 1 ] - ( S1*sy[2] );\n\t\tdy3 = sy[ 0 ] - ( S2*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\tix += dx0;\n\t\t\t\t\tiy += dy0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t\tiy += dy1;\n\t\t\t}\n\t\t\tix += dx2;\n\t\t\tiy += dy2;\n\t\t}\n\t\tix += dx3;\n\t\tiy += dy3;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a five-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign5d( x, y, true );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction assign5d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdx0 = sx[ 4 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 3 ] - ( S0*sx[4] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[3] );\n\t\tdx3 = sx[ 1 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 0 ] - ( S3*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 4 ];\n\t\tdy1 = sy[ 3 ] - ( S0*sy[4] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[3] );\n\t\tdy3 = sy[ 1 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 0 ] - ( S3*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx1;\n\t\t\t\t\tiy += dy1;\n\t\t\t\t}\n\t\t\t\tix += dx2;\n\t\t\t\tiy += dy2;\n\t\t\t}\n\t\t\tix += dx3;\n\t\t\tiy += dy3;\n\t\t}\n\t\tix += dx4;\n\t\tiy += dy4;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a six-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign6d( x, y, true );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction assign6d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdx0 = sx[ 5 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 4 ] - ( S0*sx[5] );\n\t\tdx2 = sx[ 3 ] - ( S1*sx[4] );\n\t\tdx3 = sx[ 2 ] - ( S2*sx[3] );\n\t\tdx4 = sx[ 1 ] - ( S3*sx[2] );\n\t\tdx5 = sx[ 0 ] - ( S4*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 5 ];\n\t\tdy1 = sy[ 4 ] - ( S0*sy[5] );\n\t\tdy2 = sy[ 3 ] - ( S1*sy[4] );\n\t\tdy3 = sy[ 2 ] - ( S2*sy[3] );\n\t\tdy4 = sy[ 1 ] - ( S3*sy[2] );\n\t\tdy5 = sy[ 0 ] - ( S4*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t\tiy += dy2;\n\t\t\t\t}\n\t\t\t\tix += dx3;\n\t\t\t\tiy += dy3;\n\t\t\t}\n\t\t\tix += dx4;\n\t\t\tiy += dy4;\n\t\t}\n\t\tix += dx5;\n\t\tiy += dy5;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a seven-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign7d( x, y, true );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction assign7d( x, y, isRowMajor ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdx0 = sx[ 6 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 5 ] - ( S0*sx[6] );\n\t\tdx2 = sx[ 4 ] - ( S1*sx[5] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[4] );\n\t\tdx4 = sx[ 2 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 1 ] - ( S4*sx[2] );\n\t\tdx6 = sx[ 0 ] - ( S5*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 6 ];\n\t\tdy1 = sy[ 5 ] - ( S0*sy[6] );\n\t\tdy2 = sy[ 4 ] - ( S1*sy[5] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[4] );\n\t\tdy4 = sy[ 2 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 1 ] - ( S4*sy[2] );\n\t\tdy6 = sy[ 0 ] - ( S5*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx3;\n\t\t\t\t\tiy += dy3;\n\t\t\t\t}\n\t\t\t\tix += dx4;\n\t\t\t\tiy += dy4;\n\t\t\t}\n\t\t\tix += dx5;\n\t\t\tiy += dy5;\n\t\t}\n\t\tix += dx6;\n\t\tiy += dy6;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in an eight-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign8d( x, y, true );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction assign8d( x, y, isRowMajor ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdx0 = sx[ 7 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 6 ] - ( S0*sx[7] );\n\t\tdx2 = sx[ 5 ] - ( S1*sx[6] );\n\t\tdx3 = sx[ 4 ] - ( S2*sx[5] );\n\t\tdx4 = sx[ 3 ] - ( S3*sx[4] );\n\t\tdx5 = sx[ 2 ] - ( S4*sx[3] );\n\t\tdx6 = sx[ 1 ] - ( S5*sx[2] );\n\t\tdx7 = sx[ 0 ] - ( S6*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 7 ];\n\t\tdy1 = sy[ 6 ] - ( S0*sy[7] );\n\t\tdy2 = sy[ 5 ] - ( S1*sy[6] );\n\t\tdy3 = sy[ 4 ] - ( S2*sy[5] );\n\t\tdy4 = sy[ 3 ] - ( S3*sy[4] );\n\t\tdy5 = sy[ 2 ] - ( S4*sy[3] );\n\t\tdy6 = sy[ 1 ] - ( S5*sy[2] );\n\t\tdy7 = sy[ 0 ] - ( S6*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx4;\n\t\t\t\t\tiy += dy4;\n\t\t\t\t}\n\t\t\t\tix += dx5;\n\t\t\t\tiy += dy5;\n\t\t\t}\n\t\t\tix += dx6;\n\t\t\tiy += dy6;\n\t\t}\n\t\tix += dx7;\n\t\tiy += dy7;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a nine-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign9d( x, y, true );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction assign9d( x, y, isRowMajor ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdx0 = sx[ 8 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 7 ] - ( S0*sx[8] );\n\t\tdx2 = sx[ 6 ] - ( S1*sx[7] );\n\t\tdx3 = sx[ 5 ] - ( S2*sx[6] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[5] );\n\t\tdx5 = sx[ 3 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 2 ] - ( S5*sx[3] );\n\t\tdx7 = sx[ 1 ] - ( S6*sx[2] );\n\t\tdx8 = sx[ 0 ] - ( S7*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 8 ];\n\t\tdy1 = sy[ 7 ] - ( S0*sy[8] );\n\t\tdy2 = sy[ 6 ] - ( S1*sy[7] );\n\t\tdy3 = sy[ 5 ] - ( S2*sy[6] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[5] );\n\t\tdy5 = sy[ 3 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 2 ] - ( S5*sy[3] );\n\t\tdy7 = sy[ 1 ] - ( S6*sy[2] );\n\t\tdy8 = sy[ 0 ] - ( S7*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tdy8 = sy[ 8 ] - ( S7*sy[7] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx5;\n\t\t\t\t\tiy += dy5;\n\t\t\t\t}\n\t\t\t\tix += dx6;\n\t\t\t\tiy += dy6;\n\t\t\t}\n\t\t\tix += dx7;\n\t\t\tiy += dy7;\n\t\t}\n\t\tix += dx8;\n\t\tiy += dy8;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a ten-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* assign10d( x, y, true );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction assign10d( x, y, isRowMajor ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar dy9;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdx0 = sx[ 9 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 8 ] - ( S0*sx[9] );\n\t\tdx2 = sx[ 7 ] - ( S1*sx[8] );\n\t\tdx3 = sx[ 6 ] - ( S2*sx[7] );\n\t\tdx4 = sx[ 5 ] - ( S3*sx[6] );\n\t\tdx5 = sx[ 4 ] - ( S4*sx[5] );\n\t\tdx6 = sx[ 3 ] - ( S5*sx[4] );\n\t\tdx7 = sx[ 2 ] - ( S6*sx[3] );\n\t\tdx8 = sx[ 1 ] - ( S7*sx[2] );\n\t\tdx9 = sx[ 0 ] - ( S8*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 9 ];\n\t\tdy1 = sy[ 8 ] - ( S0*sy[9] );\n\t\tdy2 = sy[ 7 ] - ( S1*sy[8] );\n\t\tdy3 = sy[ 6 ] - ( S2*sy[7] );\n\t\tdy4 = sy[ 5 ] - ( S3*sy[6] );\n\t\tdy5 = sy[ 4 ] - ( S4*sy[5] );\n\t\tdy6 = sy[ 3 ] - ( S5*sy[4] );\n\t\tdy7 = sy[ 2 ] - ( S6*sy[3] );\n\t\tdy8 = sy[ 1 ] - ( S7*sy[2] );\n\t\tdy9 = sy[ 0 ] - ( S8*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] );\n\t\tdx9 = sx[ 9 ] - ( S8*sx[8] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tdy8 = sy[ 8 ] - ( S7*sy[7] );\n\t\tdy9 = sy[ 9 ] - ( S8*sy[8] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx6;\n\t\t\t\t\tiy += dy6;\n\t\t\t\t}\n\t\t\t\tix += dx7;\n\t\t\t\tiy += dy7;\n\t\t\t}\n\t\t\tix += dx8;\n\t\t\tiy += dy8;\n\t\t}\n\t\tix += dx9;\n\t\tiy += dy9;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a zero-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var ybuf = new Complex64Array( 2 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [];\n*\n* // Define the array strides:\n* var sx = [ 0 ];\n* var sy = [ 0 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign0d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 3.0\n*\n* var im = imagf( v );\n* // returns 4.0\n*/\nfunction assign0d( x, y ) {\n\ty.accessors[ 1 ]( y.data, y.offset, x.accessors[ 0 ]( x.data, x.offset ) );\n}\n\n\n// EXPORTS //\n\nexport default assign0d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a one-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 4 ];\n*\n* // Define the array strides:\n* var sx = [ 1 ];\n* var sy = [ 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign1d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign1d( x, y ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dy0;\n\tvar S0;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables: dimensions and loop offset (pointer) increments...\n\tS0 = x.shape[ 0 ];\n\tdx0 = x.strides[ 0 ];\n\tdy0 = y.strides[ 0 ];\n\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\tix += dx0;\n\t\tiy += dy0;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a two-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign2d( x, y, true );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign2d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dy0;\n\tvar dy1;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdx0 = sx[ 1 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 0 ] - ( S0*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 1 ];\n\t\tdy1 = sy[ 0 ] - ( S0*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\tix += dx0;\n\t\t\tiy += dy0;\n\t\t}\n\t\tix += dx1;\n\t\tiy += dy1;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a three-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign3d( x, y, true );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign3d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdx0 = sx[ 2 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx2 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 2 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[2] );\n\t\tdy2 = sy[ 0 ] - ( S1*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\tix += dx0;\n\t\t\t\tiy += dy0;\n\t\t\t}\n\t\t\tix += dx1;\n\t\t\tiy += dy1;\n\t\t}\n\t\tix += dx2;\n\t\tiy += dy2;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a four-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign4d( x, y, true );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign4d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdx0 = sx[ 3 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 2 ] - ( S0*sx[3] );\n\t\tdx2 = sx[ 1 ] - ( S1*sx[2] );\n\t\tdx3 = sx[ 0 ] - ( S2*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 3 ];\n\t\tdy1 = sy[ 2 ] - ( S0*sy[3] );\n\t\tdy2 = sy[ 1 ] - ( S1*sy[2] );\n\t\tdy3 = sy[ 0 ] - ( S2*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\tix += dx0;\n\t\t\t\t\tiy += dy0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t\tiy += dy1;\n\t\t\t}\n\t\t\tix += dx2;\n\t\t\tiy += dy2;\n\t\t}\n\t\tix += dx3;\n\t\tiy += dy3;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a five-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign5d( x, y, true );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign5d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdx0 = sx[ 4 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 3 ] - ( S0*sx[4] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[3] );\n\t\tdx3 = sx[ 1 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 0 ] - ( S3*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 4 ];\n\t\tdy1 = sy[ 3 ] - ( S0*sy[4] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[3] );\n\t\tdy3 = sy[ 1 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 0 ] - ( S3*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx1;\n\t\t\t\t\tiy += dy1;\n\t\t\t\t}\n\t\t\t\tix += dx2;\n\t\t\t\tiy += dy2;\n\t\t\t}\n\t\t\tix += dx3;\n\t\t\tiy += dy3;\n\t\t}\n\t\tix += dx4;\n\t\tiy += dy4;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a six-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign6d( x, y, true );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign6d( x, y, isRowMajor ) {\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdx0 = sx[ 5 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 4 ] - ( S0*sx[5] );\n\t\tdx2 = sx[ 3 ] - ( S1*sx[4] );\n\t\tdx3 = sx[ 2 ] - ( S2*sx[3] );\n\t\tdx4 = sx[ 1 ] - ( S3*sx[2] );\n\t\tdx5 = sx[ 0 ] - ( S4*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 5 ];\n\t\tdy1 = sy[ 4 ] - ( S0*sy[5] );\n\t\tdy2 = sy[ 3 ] - ( S1*sy[4] );\n\t\tdy3 = sy[ 2 ] - ( S2*sy[3] );\n\t\tdy4 = sy[ 1 ] - ( S3*sy[2] );\n\t\tdy5 = sy[ 0 ] - ( S4*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t\tiy += dy2;\n\t\t\t\t}\n\t\t\t\tix += dx3;\n\t\t\t\tiy += dy3;\n\t\t\t}\n\t\t\tix += dx4;\n\t\t\tiy += dy4;\n\t\t}\n\t\tix += dx5;\n\t\tiy += dy5;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a seven-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign7d( x, y, true );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign7d( x, y, isRowMajor ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdx0 = sx[ 6 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 5 ] - ( S0*sx[6] );\n\t\tdx2 = sx[ 4 ] - ( S1*sx[5] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[4] );\n\t\tdx4 = sx[ 2 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 1 ] - ( S4*sx[2] );\n\t\tdx6 = sx[ 0 ] - ( S5*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 6 ];\n\t\tdy1 = sy[ 5 ] - ( S0*sy[6] );\n\t\tdy2 = sy[ 4 ] - ( S1*sy[5] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[4] );\n\t\tdy4 = sy[ 2 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 1 ] - ( S4*sy[2] );\n\t\tdy6 = sy[ 0 ] - ( S5*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx3;\n\t\t\t\t\tiy += dy3;\n\t\t\t\t}\n\t\t\t\tix += dx4;\n\t\t\t\tiy += dy4;\n\t\t\t}\n\t\t\tix += dx5;\n\t\t\tiy += dy5;\n\t\t}\n\t\tix += dx6;\n\t\tiy += dy6;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in an eight-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign8d( x, y, true );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign8d( x, y, isRowMajor ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdx0 = sx[ 7 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 6 ] - ( S0*sx[7] );\n\t\tdx2 = sx[ 5 ] - ( S1*sx[6] );\n\t\tdx3 = sx[ 4 ] - ( S2*sx[5] );\n\t\tdx4 = sx[ 3 ] - ( S3*sx[4] );\n\t\tdx5 = sx[ 2 ] - ( S4*sx[3] );\n\t\tdx6 = sx[ 1 ] - ( S5*sx[2] );\n\t\tdx7 = sx[ 0 ] - ( S6*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 7 ];\n\t\tdy1 = sy[ 6 ] - ( S0*sy[7] );\n\t\tdy2 = sy[ 5 ] - ( S1*sy[6] );\n\t\tdy3 = sy[ 4 ] - ( S2*sy[5] );\n\t\tdy4 = sy[ 3 ] - ( S3*sy[4] );\n\t\tdy5 = sy[ 2 ] - ( S4*sy[3] );\n\t\tdy6 = sy[ 1 ] - ( S5*sy[2] );\n\t\tdy7 = sy[ 0 ] - ( S6*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx4;\n\t\t\t\t\tiy += dy4;\n\t\t\t\t}\n\t\t\t\tix += dx5;\n\t\t\t\tiy += dy5;\n\t\t\t}\n\t\t\tix += dx6;\n\t\t\tiy += dy6;\n\t\t}\n\t\tix += dx7;\n\t\tiy += dy7;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a nine-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign9d( x, y, true );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign9d( x, y, isRowMajor ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdx0 = sx[ 8 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 7 ] - ( S0*sx[8] );\n\t\tdx2 = sx[ 6 ] - ( S1*sx[7] );\n\t\tdx3 = sx[ 5 ] - ( S2*sx[6] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[5] );\n\t\tdx5 = sx[ 3 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 2 ] - ( S5*sx[3] );\n\t\tdx7 = sx[ 1 ] - ( S6*sx[2] );\n\t\tdx8 = sx[ 0 ] - ( S7*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 8 ];\n\t\tdy1 = sy[ 7 ] - ( S0*sy[8] );\n\t\tdy2 = sy[ 6 ] - ( S1*sy[7] );\n\t\tdy3 = sy[ 5 ] - ( S2*sy[6] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[5] );\n\t\tdy5 = sy[ 3 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 2 ] - ( S5*sy[3] );\n\t\tdy7 = sy[ 1 ] - ( S6*sy[2] );\n\t\tdy8 = sy[ 0 ] - ( S7*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tdy8 = sy[ 8 ] - ( S7*sy[7] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx5;\n\t\t\t\t\tiy += dy5;\n\t\t\t\t}\n\t\t\t\tix += dx6;\n\t\t\t\tiy += dy6;\n\t\t\t}\n\t\t\tix += dx7;\n\t\t\tiy += dy7;\n\t\t}\n\t\tix += dx8;\n\t\tiy += dy8;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MAIN //\n\n/**\n* Assigns elements in a ten-dimensional input ndarray to elements in an equivalently shaped output ndarray.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* assign10d( x, y, true );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction assign10d( x, y, isRowMajor ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar dy9;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar sy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tsy = y.strides;\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdx0 = sx[ 9 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 8 ] - ( S0*sx[9] );\n\t\tdx2 = sx[ 7 ] - ( S1*sx[8] );\n\t\tdx3 = sx[ 6 ] - ( S2*sx[7] );\n\t\tdx4 = sx[ 5 ] - ( S3*sx[6] );\n\t\tdx5 = sx[ 4 ] - ( S4*sx[5] );\n\t\tdx6 = sx[ 3 ] - ( S5*sx[4] );\n\t\tdx7 = sx[ 2 ] - ( S6*sx[3] );\n\t\tdx8 = sx[ 1 ] - ( S7*sx[2] );\n\t\tdx9 = sx[ 0 ] - ( S8*sx[1] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 9 ];\n\t\tdy1 = sy[ 8 ] - ( S0*sy[9] );\n\t\tdy2 = sy[ 7 ] - ( S1*sy[8] );\n\t\tdy3 = sy[ 6 ] - ( S2*sy[7] );\n\t\tdy4 = sy[ 5 ] - ( S3*sy[6] );\n\t\tdy5 = sy[ 4 ] - ( S4*sy[5] );\n\t\tdy6 = sy[ 3 ] - ( S5*sy[4] );\n\t\tdy7 = sy[ 2 ] - ( S6*sy[3] );\n\t\tdy8 = sy[ 1 ] - ( S7*sy[2] );\n\t\tdy9 = sy[ 0 ] - ( S8*sy[1] );\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] );\n\t\tdx9 = sx[ 9 ] - ( S8*sx[8] ); // offset increment for outermost loop\n\t\tdy0 = sy[ 0 ];\n\t\tdy1 = sy[ 1 ] - ( S0*sy[0] );\n\t\tdy2 = sy[ 2 ] - ( S1*sy[1] );\n\t\tdy3 = sy[ 3 ] - ( S2*sy[2] );\n\t\tdy4 = sy[ 4 ] - ( S3*sy[3] );\n\t\tdy5 = sy[ 5 ] - ( S4*sy[4] );\n\t\tdy6 = sy[ 6 ] - ( S5*sy[5] );\n\t\tdy7 = sy[ 7 ] - ( S6*sy[6] );\n\t\tdy8 = sy[ 8 ] - ( S7*sy[7] );\n\t\tdy9 = sy[ 9 ] - ( S8*sy[8] );\n\t}\n\t// Set the pointers to the first indexed elements in the respective ndarrays...\n\tix = x.offset;\n\tiy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache accessors:\n\tget = x.accessors[ 0 ];\n\tset = y.accessors[ 1 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx6;\n\t\t\t\t\tiy += dy6;\n\t\t\t\t}\n\t\t\t\tix += dx7;\n\t\t\t\tiy += dy7;\n\t\t\t}\n\t\t\tix += dx8;\n\t\t\tiy += dy8;\n\t\t}\n\t\tix += dx9;\n\t\tiy += dy9;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default assign10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a two-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Float64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* blockedassign2d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0 ]\n*/\nfunction blockedassign2d( x, y ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dy0;\n\tvar dy1;\n\tvar ox1;\n\tvar oy1;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tox1 = ox + ( j1*sx[1] );\n\t\toy1 = oy + ( j1*sy[1] );\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t// Compute loop offset increments...\n\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t// Iterate over the ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\tix += dx0;\n\t\t\t\t\tiy += dy0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t\tiy += dy1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a three-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n* var sy = [ 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* blockedassign3d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction blockedassign3d( x, y ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar ox1;\n\tvar ox2;\n\tvar oy1;\n\tvar oy2;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tox2 = ox + ( j2*sx[2] );\n\t\toy2 = oy + ( j2*sy[2] );\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t// Compute loop offset increments...\n\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t\tiy += dy2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a four-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n* var sy = [ 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* blockedassign4d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction blockedassign4d( x, y ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tox3 = ox + ( j3*sx[3] );\n\t\toy3 = oy + ( j3*sy[3] );\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a five-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* blockedassign5d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction blockedassign5d( x, y ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tox4 = ox + ( j4*sx[4] );\n\t\toy4 = oy + ( j4*sy[4] );\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a six-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* blockedassign6d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction blockedassign6d( x, y ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tox5 = ox + ( j5*sx[5] );\n\t\toy5 = oy + ( j5*sy[5] );\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a seven-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* blockedassign7d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction blockedassign7d( x, y ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tox6 = ox + ( j6*sx[6] );\n\t\toy6 = oy + ( j6*sy[6] );\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\tdy6 = sy[6] - ( s5*sy[5] );\n\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in an eight-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* blockedassign8d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction blockedassign8d( x, y ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tox7 = ox + ( j7*sx[7] );\n\t\toy7 = oy + ( j7*sy[7] );\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\tdy7 = sy[7] - ( s6*sy[6] );\n\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\tdy6 = sy[6] - ( s5*sy[5] );\n\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a nine-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* blockedassign9d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction blockedassign9d( x, y ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar oy8;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tox8 = ox + ( j8*sx[8] );\n\t\toy8 = oy + ( j8*sy[8] );\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\tdy8 = sy[8] - ( s7*sy[7] );\n\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\toy7 = oy8 + ( j7*sy[7] );\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\tdy7 = sy[7] - ( s6*sy[6] );\n\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\tdy6 = sy[6] - ( s5*sy[5] );\n\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy8;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a ten-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( 6 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n* var sy = [ 6, 6, 6, 6, 6, 6, 6, 2, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 1;\n* var oy = 0;\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Copy elements:\n* blockedassign10d( x, y );\n*\n* console.log( y.data );\n* // => <Float64Array>[ 2.0, 3.0, 6.0, 7.0, 10.0, 11.0 ]\n*/\nfunction blockedassign10d( x, y ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar dy9;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar ox9;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar oy8;\n\tvar oy9;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tox9 = ox + ( j9*sx[9] );\n\t\toy9 = oy + ( j9*sy[9] );\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tdx9 = sx[9] - ( s8*sx[8] );\n\t\t\tdy9 = sy[9] - ( s8*sy[8] );\n\t\t\tox8 = ox9 + ( j8*sx[8] );\n\t\t\toy8 = oy9 + ( j8*sy[8] );\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\t\tdy8 = sy[8] - ( s7*sy[7] );\n\t\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\t\toy7 = oy8 + ( j7*sy[7] );\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\t\tdy7 = sy[7] - ( s6*sy[6] );\n\t\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\t\tdy6 = sy[6] - ( s5*sy[5] );\n\t\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tybuf[ iy ] = xbuf[ ix ];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy8;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx9;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a two-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* blockedassign2d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction blockedassign2d( x, y ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dy0;\n\tvar dy1;\n\tvar ox1;\n\tvar oy1;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tox1 = ox + ( j1*sx[1] );\n\t\toy1 = oy + ( j1*sy[1] );\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t// Compute loop offset increments...\n\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t// Iterate over the ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\tix += dx0;\n\t\t\t\t\tiy += dy0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t\tiy += dy1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a three-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* blockedassign3d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction blockedassign3d( x, y ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar ox1;\n\tvar ox2;\n\tvar oy1;\n\tvar oy2;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tox2 = ox + ( j2*sx[2] );\n\t\toy2 = oy + ( j2*sy[2] );\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t// Compute loop offset increments...\n\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t\tiy += dy2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a four-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* blockedassign4d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction blockedassign4d( x, y ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tox3 = ox + ( j3*sx[3] );\n\t\toy3 = oy + ( j3*sy[3] );\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a five-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* blockedassign5d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction blockedassign5d( x, y ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tox4 = ox + ( j4*sx[4] );\n\t\toy4 = oy + ( j4*sy[4] );\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a six-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* blockedassign6d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction blockedassign6d( x, y ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tox5 = ox + ( j5*sx[5] );\n\t\toy5 = oy + ( j5*sy[5] );\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a seven-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* blockedassign7d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction blockedassign7d( x, y ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tox6 = ox + ( j6*sx[6] );\n\t\toy6 = oy + ( j6*sy[6] );\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\tdy6 = sy[6] - ( s5*sy[5] );\n\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in an eight-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* blockedassign8d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction blockedassign8d( x, y ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tox7 = ox + ( j7*sx[7] );\n\t\toy7 = oy + ( j7*sy[7] );\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\tdy7 = sy[7] - ( s6*sy[6] );\n\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\tdy6 = sy[6] - ( s5*sy[5] );\n\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a nine-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* blockedassign9d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction blockedassign9d( x, y ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar oy8;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tox8 = ox + ( j8*sx[8] );\n\t\toy8 = oy + ( j8*sy[8] );\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\tdy8 = sy[8] - ( s7*sy[7] );\n\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\toy7 = oy8 + ( j7*sy[7] );\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\tdy7 = sy[7] - ( s6*sy[6] );\n\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\tdy6 = sy[6] - ( s5*sy[5] );\n\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\tiy += dy8;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\n\n\n// MAIN //\n\n/**\n* Assigns elements in a ten-dimensional input ndarray to elements in an equivalently shaped output ndarray via loop blocking.\n*\n* @private\n* @param {Object} x - object containing input ndarray meta data\n* @param {*} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Object} y - object containing output ndarray meta data\n* @param {*} y.dtype - data type\n* @param {Collection} y.data - data buffer\n* @param {NonNegativeIntegerArray} y.shape - dimensions\n* @param {IntegerArray} y.strides - stride lengths\n* @param {NonNegativeInteger} y.offset - index offset\n* @param {string} y.order - specifies whether `y` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} y.accessors - data buffer accessors\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* // Create data buffers:\n* var xbuf = new Complex64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );\n* var ybuf = new Complex64Array( 4 );\n*\n* // Define the shape of the input and output arrays:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n* var sy = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create the input and output ndarray-like objects:\n* var x = {\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n* var y = {\n*     'dtype': 'complex64',\n*     'data': ybuf,\n*     'shape': shape,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Copy elements:\n* blockedassign10d( x, y );\n*\n* var v = y.data.get( 0 );\n*\n* var re = realf( v );\n* // returns 1.0\n*\n* var im = imagf( v );\n* // returns 2.0\n*/\nfunction blockedassign10d( x, y ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar ybuf;\n\tvar get;\n\tvar set;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar dy0;\n\tvar dy1;\n\tvar dy2;\n\tvar dy3;\n\tvar dy4;\n\tvar dy5;\n\tvar dy6;\n\tvar dy7;\n\tvar dy8;\n\tvar dy9;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar ox9;\n\tvar oy1;\n\tvar oy2;\n\tvar oy3;\n\tvar oy4;\n\tvar oy5;\n\tvar oy6;\n\tvar oy7;\n\tvar oy8;\n\tvar oy9;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sx;\n\tvar sy;\n\tvar ox;\n\tvar oy;\n\tvar ix;\n\tvar iy;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides, y.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tsy = o.sy;\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Cache the indices of the first indexed elements in the respective ndarrays...\n\tox = x.offset;\n\toy = y.offset;\n\n\t// Cache references to the input and output ndarray buffers...\n\txbuf = x.data;\n\tybuf = y.data;\n\n\t// Cache offset increments for the innermost loop...\n\tdx0 = sx[0];\n\tdy0 = sy[0];\n\n\t// Cache accessors:\n\tget = x.accessors[0];\n\tset = y.accessors[1];\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tox9 = ox + ( j9*sx[9] );\n\t\toy9 = oy + ( j9*sy[9] );\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tdx9 = sx[9] - ( s8*sx[8] );\n\t\t\tdy9 = sy[9] - ( s8*sy[8] );\n\t\t\tox8 = ox9 + ( j8*sx[8] );\n\t\t\toy8 = oy9 + ( j8*sy[8] );\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\t\tdy8 = sy[8] - ( s7*sy[7] );\n\t\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\t\toy7 = oy8 + ( j7*sy[7] );\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\t\tdy7 = sy[7] - ( s6*sy[6] );\n\t\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\t\toy6 = oy7 + ( j6*sy[6] );\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\t\tdy6 = sy[6] - ( s5*sy[5] );\n\t\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\t\toy5 = oy6 + ( j5*sy[5] );\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\t\tdy5 = sy[5] - ( s4*sy[4] );\n\t\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\t\toy4 = oy5 + ( j4*sy[4] );\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\t\tdy4 = sy[4] - ( s3*sy[3] );\n\t\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\t\toy3 = oy4 + ( j3*sy[3] );\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\t\tdy3 = sy[3] - ( s2*sy[2] );\n\t\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\t\toy2 = oy3 + ( j2*sy[2] );\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tdy2 = sy[2] - ( s1*sy[1] );\n\t\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\t\toy1 = oy2 + ( j1*sy[1] );\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute index offsets for the first input and output ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\t\t\t\t\t\t\t\t\t\t\tiy = oy1 + ( j0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Compute loop offset increments...\n\t\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\t\t\t\t\t\t\t\t\t\t\tdy1 = sy[1] - ( s0*sy[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset( ybuf, iy, get( xbuf, ix ) );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\t\t\tiy += dy8;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx9;\n\t\t\t\t\t\t\t\t\t\t\t\tiy += dy9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedassign10d;\n"],"names":["MODE","ASSIGN","x","y","data","offset","xbuf","ybuf","dx0","dy0","S0","ix","iy","i0","shape","strides","isRowMajor","dx1","dy1","sh","S1","sx","sy","i1","dx2","dy2","S2","i2","dx3","dy3","S3","i3","dx4","dy4","S4","i4","dx5","dy5","S5","i5","dx6","dy6","S6","i6","dx7","dy7","S7","i7","dx8","dy8","S8","i8","dx9","dy9","S9","i9","ACCESSOR_ASSIGN","accessors","get","set","BLOCKED_ASSIGN","bsize","ox1","oy1","s0","s1","ox","oy","j0","j1","o","loopOrder","blockSize","dtype","ox2","oy2","s2","j2","ox3","oy3","s3","j3","ox4","oy4","s4","j4","ox5","oy5","s5","j5","ox6","oy6","s6","j6","ox7","oy7","s7","j7","ox8","oy8","s8","j8","ox9","oy9","s9","j9","BLOCKED_ACCESSOR_ASSIGN","MAX_DIMS","length","COMPLEX_TO_REAL","complex128","complex64","complex32","boolean2uint8","reinterpretBoolean","accessorProtocol","complex2real","ndims","reinterpretComplex","String","gscal","push","assign","arrays","xmmv","ymmv","shx","shy","iox","ioy","len","ord","ns","d","i","ndarray2object","isBooleanArray","isComplexArray","isRealDataType","isComplexDataType","castReturn","complexCtors","Error","format","iterationOrder","strides2order","minmaxViewBufferIndex","ordx","ordy","numel","order","vind2bind","accessorassignnd","assignnd"],"mappings":"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"}